# -*- coding: utf-8 -*-
"""Analysis_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ovA64iBTwU_huANNPChd0fMWAlJR2xCP
"""

# Data Wise Analysis

## Section 1: Import Required Libraries

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkcalendar import DateEntry
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg


## Section 2: Load and Prepare the Dataset

# Local file path
file_path = r'src\main\resources\scripts\Unitech_Ind_Imports_Data.csv'

# Load the data
data = pd.read_csv(file_path)
data.columns = data.columns.str.strip()

# Convert 'Date' column to datetime
data['Date'] = pd.to_datetime(data['Date'], errors='coerce')

def filter_data_by_date(start_date, end_date):
    """Filter data within the given date range."""
    return data[(data['Date'] >= start_date) & (data['Date'] <= end_date)]


## Section 3: Analysis Functions

# Analysis functions
def analyze_quantity_supplied(filtered_data):
    supplier_quantity = filtered_data.groupby('Supplier Name')['Product Quantity'].sum().sort_values(ascending=False)
    return supplier_quantity

def quantity_supplied_prediction(filtered_data):
    top_supplier = analyze_quantity_supplied(filtered_data).idxmax()
    return f"Supplier '{top_supplier}' has the highest quantity supplied, indicating a consistent high demand for their products."

def analyze_payment_status(filtered_data):
    return filtered_data['Payment Status'].value_counts()

def payment_status_prediction(filtered_data):
    unpaid_count = analyze_payment_status(filtered_data).get('Unpaid', 0)
    if unpaid_count > 0:
        return "A significant number of payments are pending, which could impact cash flow management."
    return "Most payments are cleared, indicating good financial health."

def analyze_last_month_imports(filtered_data):
    last_month = datetime.now().month - 1
    last_month_data = filtered_data[filtered_data['Date'].dt.month == last_month]
    product_quantity = last_month_data.groupby('Product ID')['Product Quantity'].sum().sort_values(ascending=False)
    return product_quantity

def last_month_imports_prediction(filtered_data):
    product_imports = analyze_last_month_imports(filtered_data)
    if not product_imports.empty:
        top_product = product_imports.idxmax()
        return f"Product ID '{top_product}' was in high demand last month, indicating a trend in customer preference."
    return "No data available for imports from the last month."


## Section 4: Visualization Functions

def create_visual(frame, func, title, chart_type, prediction, filtered_data):
    fig, ax = plt.subplots(figsize=(10, 6))
    data = func(filtered_data)

    if chart_type == 'bar':
        sns.barplot(x=data.index, y=data.values, ax=ax, palette='viridis')
        ax.set_title(title)
        ax.set_xticklabels(data.index, rotation=45, ha='right')
    elif chart_type == 'pie':
        ax.pie(data, labels=data.index, autopct='%1.1f%%', startangle=140, colors=sns.color_palette('viridis', len(data)))
        ax.set_title(title)
    elif chart_type == 'hist':
        sns.histplot(data, ax=ax, kde=True, color='skyblue')
        ax.set_title(title)

    plt.tight_layout()
    canvas = FigureCanvasTkAgg(fig, frame)
    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    # Add prediction text
    prediction_label = tk.Label(frame, text=prediction, font=('Arial', 12), wraplength=1400, justify='left', fg='blue')
    prediction_label.pack(pady=10)


## Section 5: GUI Setup and Main Functionality

# Tkinter GUI
root = tk.Tk()
root.title('Data Visualization Dashboard')
root.geometry('1500x1000')

def show_date_selector():
    def analyze_with_date():
        try:
            start_date = datetime.strptime(start_date_entry.get(), '%Y-%m-%d')
            end_date = datetime.strptime(end_date_entry.get(), '%Y-%m-%d')

            if start_date > end_date:
                messagebox.showerror("Error", "Start date must be before or equal to end date.")
                return

            filtered_data = filter_data_by_date(start_date, end_date)

            if filtered_data.empty:
                messagebox.showinfo("No Data", "No data available for the selected date range.")
                return

            # Clear previous visuals
            for widget in scrollable_frame.winfo_children():
                widget.destroy()

            # Add visualizations for the filtered data
            visuals = [
                (analyze_quantity_supplied, 'Total Quantity Supplied by Each Supplier (Bar)', 'bar', quantity_supplied_prediction(filtered_data), filtered_data),
                (analyze_quantity_supplied, 'Proportion of Quantity Supplied (Pie)', 'pie', quantity_supplied_prediction(filtered_data), filtered_data),
                (analyze_quantity_supplied, 'Distribution of Product Quantity (Histogram)', 'hist', quantity_supplied_prediction(filtered_data), filtered_data),
                (analyze_payment_status, 'Payment Status Distribution (Bar)', 'bar', payment_status_prediction(filtered_data), filtered_data),
                (analyze_payment_status, 'Payment Status Proportion (Pie)', 'pie', payment_status_prediction(filtered_data), filtered_data),
                (analyze_payment_status, 'Quantities in Pending Payments (Histogram)', 'hist', payment_status_prediction(filtered_data), filtered_data),
                (analyze_last_month_imports, 'Last Month Imports (Bar)', 'bar', last_month_imports_prediction(filtered_data), filtered_data),
                (analyze_last_month_imports, 'Proportion of Last Month Imports (Pie)', 'pie', last_month_imports_prediction(filtered_data), filtered_data),
                (analyze_last_month_imports, 'Last Month Imports (Histogram)', 'hist', last_month_imports_prediction(filtered_data), filtered_data),
            ]

            for i, (func, title, chart_type, prediction, f_data) in enumerate(visuals):
                frame = ttk.Frame(scrollable_frame, height=1500, width=1500)
                frame.grid(row=i, column=0, pady=20)
                create_visual(frame, func, title, chart_type, prediction, f_data)

        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    # Date selector popup
    date_selector = tk.Toplevel(root)
    date_selector.title("Select Date Range")
    date_selector.geometry("400x300+" + str(root.winfo_x() + 600) + "+" + str(root.winfo_y() + 300))
    date_selector.configure(bg='#f0f8ff')

    tk.Label(date_selector, text="From Date (YYYY-MM-DD):", font=('Arial', 12), bg='#f0f8ff').pack(pady=10)
    start_date_entry = DateEntry(date_selector, date_pattern='y-mm-dd', font=('Arial', 12))
    start_date_entry.pack(pady=5)

    tk.Label(date_selector, text="To Date (YYYY-MM-DD):", font=('Arial', 12), bg='#f0f8ff').pack(pady=10)
    end_date_entry = DateEntry(date_selector, date_pattern='y-mm-dd', font=('Arial', 12))
    end_date_entry.pack(pady=5)

    tk.Button(date_selector, text="Analyze", command=analyze_with_date, font=('Arial', 14, 'bold'), bg='#007acc', fg='white', padx=20, pady=10).pack(pady=20)

# Main interface
main_frame = tk.Frame(root)
main_frame.pack(fill=tk.BOTH, expand=True)

canvas = tk.Canvas(main_frame)
scrollbar = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=canvas.yview)
scrollable_frame = ttk.Frame(canvas)

scrollable_frame.bind(
    '<Configure>',
    lambda e: canvas.configure(scrollregion=canvas.bbox('all'))
)

canvas.create_window((0, 0), window=scrollable_frame, anchor='nw')
canvas.configure(yscrollcommand=scrollbar.set)

canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

# Add mouse and touchpad scrolling
def on_mouse_wheel(event):
    canvas.yview_scroll(-1 * (event.delta // 120), 'units')

# Bind scrolling events for mouse wheel and touchpad
root.bind_all('<MouseWheel>', on_mouse_wheel)  # Windows
root.bind_all('<Button-4>', lambda e: canvas.yview_scroll(-1, 'units'))  # Linux scroll up
root.bind_all('<Button-5>', lambda e: canvas.yview_scroll(1, 'units'))  # Linux scroll down


# Button to open date selector (right side, middle)
select_date_button = tk.Button(root, text="Select Date Range", command=show_date_selector, font=('Arial', 16, 'bold'), bg='#007acc', fg='white', padx=30, pady=10)
select_date_button.pack(side=tk.RIGHT, padx=100, pady=50)

# Run the application
root.mainloop()